from multiserver_attacker import Attacker
from multiprocessing import Process, Pool
from icecream import ic
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Util.number import long_to_bytes, bytes_to_long
from LLL.lll import LLLWrapper
from pathlib import Path
from socket import SHUT_RDWR
from sage.all import matrix, ZZ


ans_1 = range(
    6438054122906314408409721174104876429399718790484564312785724246594172591906820417228198020586489937650965792750789003224873919133208824364839189116226418484353855538565792241450796269677143813946969762340885898256180634033451967905229005843015695940786719559160154383965171137485126678510138955308214053,
    6438054122906314408409721174104876429399718790484564312785724246594172591906820417228198020586489937650965792750789003224873919133208824364839189116226418484353855538565792241450796269677143813946969762340885898256180634033451967905229005843015695940786719559287130326959848249419240522107668775047747958,
)
s0_1 = 43473287096037689503785911535123525426582291372386791344790259206293241815860856486136174887491313956519417566289154668953685335824661614744911004034337363759518372404161702659462594935059958969136594879226723579083623918190760427123880515353965859224115348788204386896783059310029197995302304195947273123885

ans_2 = range(
    6451496800443687979923601293572157068318036004980092809813590651683684677562766978893965613914037191952567478246860616469614555639485336516070352910650825975093462507646224055241935167302865929891309264947825267010691276173941988139982652367554148442013850952911701357513425358100014671590475193179034795,
    6451496800443687979923601293572157068318036004980092809813590651683684677562766978893965613914037191952567478246860616469614555639485336516070352910650825975093462507646224055241935167302865929891309264947825267010691276173941988139982652367554148442027363474852841294975961490876950499732826811687503222,
)
s0_2 = 45801721172914270076491081146262143797268594056572731815867607770562953671739915543716201356676786083302125138439470655400216869849986351585653314439986003433924989579327561132225001435043971015304092343055704400713045073135419392285158290972087054976053874594039773360404155056060691243970753149646371050688

ans_3 = range(
    7831787368757902065403461221932390402912370263323364220857468724347382724529750332513039141111295995021919938661596647450043027336163426695559119400146736645383041427680030538637026470104124843725569578683561996240221021996936930252428946189632971883177482242702133004016872848619425963368064171511262929,
    7831787368757902065403461221932390402912370263323364220857468724347382724529750332513039141111295995021919938661596647450043027336163426695559119400146736645383041427680030538637026470104124843725569578683561996240221021996936930925446308648878139094342469185013765865555507074682099657901035720555125746,
)
s0_3 = 128208967292937382311616737130769633691839537839640536762543621544811274571595956588983646291287138998779961717193622533266560974675837571467572782849569950576793928146768305467039294224440424431744640653994522956042165601812468077275809387084643161107476861014596889082447559791317773442475666756357527841032

ans_4 = range(
    5526074031545925535031688842215584541449578489168526512832630561902327668762494073972171842624641217789937682187441655827498651024518658260595227191009830963718657476250002223943936162158272891330371596297356122636454526434417323902912904357603541175298301937501877149593772829301620573805877128230330364,
    5526074031545925535031688842215584541449578489168526512832630561902327668762494073972171842624641217789937682187441655827498651024518658260595227191009830963718657476250002223943936162158272891330371596297356122636454526434417323906628182914241849833077673816398015534042465793228100433459353761308922103,
)
s0_4 = 117912765874262463697934672239385953503929067886113083194378400872285053680943032492041817366110303335330078607910359774351343176636867807065340626747252566100120615831570116311446669960999561186517316171424938272753562683460940030911370909519026362620489450633838890283573198018254660799149613317033266704164


LLL = LLLWrapper(
    Path("attack/LLL/liblll.so")
)  # ! maybe should return a list[list[int]] instead of list[list[float]]
lll = LLL.lll


def get_public() -> tuple[int, int]:
    with open("public_key.rsa", "rb") as key_file:
        pub_key = RSA.import_key(key_file.read())
    return pub_key.n, pub_key.e


def get_cipher() -> int:
    msg = b"hello_world"
    with open("public_key.rsa", "rb") as key_file:
        pub_key = RSA.import_key(key_file.read())
    cipher_rsa = PKCS1_v1_5.new(pub_key)

    return bytes_to_long(cipher_rsa.encrypt(msg))


class ParallelAttacker:

    def __init__(
        self, N: int, E: int, ct: int, attacker_amount: int, host: str, ports: list[int]
    ) -> None:
        self.N = N
        self.E = E
        self.ct = ct
        self.host = host
        self.ports = ports
        self.attacker_count = attacker_amount

    def _split_into_k_lists(self, input_list: list, K: int):
        # Calculate the approximate size of each chunk
        avg_size = len(input_list) // K
        remainder = len(input_list) % K

        result = []
        start = 0

        for i in range(K):
            # Determine the end index for the current sublist
            end = start + avg_size + (1 if i < remainder else 0)
            result.append(input_list[start:end])
            start = end

        return result

    def attacker_warper(self, ports: list):
        ic("in attacker wrapper")
        ic(ports)
        attacker: Attacker = Attacker(
            self.N, self.E, self.ct, [self.host], ports, random_blinding=True
        )
        ic("created attacker")
        result = attacker.attack()
        return result

    def attack(self):
        with Pool(self.attacker_count) as pool:
            results = pool.map(
                self.attacker_warper,
                self._split_into_k_lists(self.ports, self.attacker_count),
            )

        ic("got results")
        # ic(results)

        range_list = []
        s_list = []

        for result in results:
            range_list.append(result[0])
            s_list.append(result[1])

        return self.conclusion(range_list, s_list)

    def conclusion(self, ranges: list[range], S: list[int]) -> int:
        # results = [range.start for range in ranges]
        # ic(
        #     [
        #         long_to_bytes((result * pow(s, -1, self.N) % self.N))
        #         for result, s in zip(results, S)
        #     ]
        # )

        v0 = S + [0]
        vf = [r.start for r in ranges] + [
            (self.N * (self.attacker_count - 1)) // self.attacker_count
        ]
        middle = [
            (([0] * i) + [self.N] + ([0] * (self.attacker_count - i))).copy()
            for i in range(self.attacker_count)
        ]
        M = matrix(ZZ, [v0] + middle + [vf])
        reduced_basis = list(M.LLL())
        reduced_basis.sort(key=vec_norm)
        # ic(reduced_basis)
        for R in reduced_basis:
            # R = reduced_basis[-1]
            # # ic(R)
            for i in range(len(R) - 1):
                m = ((R[i] + vf[i]) * pow(S[i], -1, self.N)) % self.N
                ic(long_to_bytes(m))
        ic(R[-1] == -(self.N * (self.attacker_count - 1)) // self.attacker_count)
        return m


def vec_norm(vec: list[int]) -> int:
    return sum(x * x for x in vec)


if __name__ == "__main__":
    HOSTS = ["localhost"] * 15
    PORTS = [8001 + i for i in range(15)]
    n, e = get_public()
    ic("got public")
    parallel = ParallelAttacker(n, e, get_cipher(), 4, HOSTS, PORTS)
    ic("created parallel attacker")
    parallel.conclusion([ans_1, ans_2, ans_3, ans_4], [s0_1, s0_2, s0_3, s0_4])
    # m = matrix(ZZ, [[7, 2], [5, 3]])
    # res, t = ic(m.LLL(transformation = True))
    # ic(t * m)
